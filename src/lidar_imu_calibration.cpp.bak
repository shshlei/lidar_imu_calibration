// Created by usl on 12/14/20.

#define PCL_NO_PRECOMPILE  // !! BEFORE ANY PCL INCLUDE!!

#include "lidar_imu_calibration/core/calibManager.h"
#include "lidar_imu_calibration/track/lidarOdometry.h"
#include "lidar_imu_calibration/utils/pcl_utils.h"
#include "lidar_imu_calibration/utils/quat_ops.h"
#include "lidar_imu_calibration/utils/parse_ros.h"

#include <rclcpp/rclcpp.hpp>
#include <rclcpp/serialization.hpp>
#include <rcutils/time.h>
#include <rosbag2_cpp/reader.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/pose_with_covariance_stamped.hpp>
#include <geometry_msgs/msg/quaternion_stamped.hpp>
#include <nav_msgs/msg/odometry.hpp>
#include <pcl/visualization/cloud_viewer.h>
#include <sensor_msgs/msg/imu.hpp>
#include <sensor_msgs/msg/point_cloud2.hpp>
#include <std_msgs/msg/float64.hpp>

#include <tf2/LinearMath/Matrix3x3.h>
#include <tf2/LinearMath/Quaternion.h>
#include <tf2/LinearMath/Vector3.h>
#include <tf2/LinearMath/Transform.h>
#include <tf2/transform_datatypes.h>
#include <tf2_ros/transform_broadcaster.h>
#include <tf2_ros/buffer_interface.h>

#include <string>
#include <iostream>
#include <fstream>
#include <memory>

using namespace lidar_imu_calibration;

void downSampleCloud(const pcl::PointCloud<lidar_imu_calibration::PointXYZIR8Y>::Ptr cloud_in_pcl, pcl::PointCloud<lidar_imu_calibration::PointXYZIR8Y>::Ptr cloud_out_pcl, int ring_downsample_factor)
{
  cloud_out_pcl->header = cloud_in_pcl->header;
  cloud_out_pcl->is_dense = cloud_in_pcl->is_dense;
  cloud_out_pcl->height = cloud_in_pcl->height;
  cloud_out_pcl->width = cloud_in_pcl->width;
  cloud_out_pcl->resize(cloud_in_pcl->width * cloud_in_pcl->height);
  for (std::size_t h = 0; h < cloud_in_pcl->height; h++) {
    for (std::size_t w = 0; w < cloud_in_pcl->width; w++) {
      lidar_imu_calibration::PointXYZIR8Y cloud_point = cloud_in_pcl->at(w, h);
      /// Ignore non even rings
      if (cloud_point.ring % ring_downsample_factor != 0)
        continue;
      /// Ignore points with NaNs
      if (isnan(cloud_point.x) || isnan(cloud_point.y) || isnan(cloud_point.z)) {
        continue;
      }
      cloud_out_pcl->at(w, h) = cloud_point;
    }
  }
}

class LidarImuCalibrationNode : public ParamServer
{
public:

  LidarImuCalibrationNode() : ParamServer("lidar_imu_calib_node")
  {
    sys_ = new calibManager(getCalibManagerOptions());

    cloud_pub_ = create_publisher<sensor_msgs::msg::PointCloud2>("/raw_cloud_out", 1);
    undistorted_cloud_pub_ = create_publisher<sensor_msgs::msg::PointCloud2>("/undistorted_cloud_out", 1);
    imu_pub_ = create_publisher<sensor_msgs::msg::Imu>("/imu_measurement_out", 1);
    lidar_pose_pub_ = create_publisher<geometry_msgs::msg::PoseStamped>("/lidar_pose_out", 1);
    imu_pose_pub_ = create_publisher<geometry_msgs::msg::PoseWithCovarianceStamped>("/imu_pose_out", 1);
    imu_odom_pub_ = create_publisher<nav_msgs::msg::Odometry>("/imu_odom_out", 1);
    map_pub_ = create_publisher<sensor_msgs::msg::PointCloud2>("/map_cloud", 1);

    topic_imu_ = declare_parameter("topic_imu_", "/imu");
    topic_lidar_ = declare_parameter("topic_lidar_", "/lidar");

    path_to_bag_ = declare_parameter("path_bag", "");
    bag_start_ = declare_parameter("bag_start_", 0);
    bag_durr_ = declare_parameter("bag_durr_", -1);

    // Read Data
    reader_.open(path_to_bag_);
    const rosbag2_storage::BagMetadata & mdata = reader_.get_metadata();
    rcutils_time_point_value_t start = mdata.starting_time.time_since_epoch().count() + RCUTILS_S_TO_NS(bag_start_);
    reader_.seek(start);
    rcutils_time_point_value_t end = start;
    if (bag_durr_ > 0) end = start + RCUTILS_S_TO_NS(bag_durr_);

    /// Broadcaster
    tf2_ros::TransformBroadcaster br1(this), br2(this), br3(this);
    tf2::Transform transform1, transform2, transform3;
    std::string lidar_first_frame;

    // Step through the rosbag
    int lidar_scan_no = 0;
    int no_of_imu = 0;

    bool first_lodom = true;
    bool first_lidar_frame = true;
    Eigen::Matrix4d G_T_I1 = Eigen::Matrix4d::Identity();
    Eigen::Matrix4d G_T_L1 = Eigen::Matrix4d::Identity();
    Eigen::Vector3d G_t_L1 = Eigen::Vector3d::Zero();
    Eigen::Quaterniond G_quat_L1;

    rclcpp::Time start_time = now();
    while (reader_.has_next()) {
      rosbag2_storage::SerializedBagMessageSharedPtr msg = reader_.read_next();
      if (msg->topic_name != topic_lidar_ || msg->topic_name != topic_imu_) continue;
      if (bag_durr_ > 0 && msg->time_stamp > end) break;

      rclcpp::SerializedMessage serialized_msg(*msg->serialized_data);
      if (msg->topic_name == topic_lidar_) {
        RCLCPP_INFO_STREAM(get_logger(), "Lidar scan no: " << lidar_scan_no);
        lidar_scan_no++;
        RCLCPP_INFO_STREAM(get_logger(), "No of imu measurements: " << no_of_imu);
        no_of_imu = 0;

        sensor_msgs::msg::PointCloud2::SharedPtr s_lidar = std::make_shared<sensor_msgs::msg::PointCloud2>();
        cloud_serialization_.deserialize_message(&serialized_msg, s_lidar.get());
        cloud_pub_->publish(*s_lidar);

        pcl::PointCloud<lidar_imu_calibration::PointXYZIR8Y>::Ptr cloud(new pcl::PointCloud<lidar_imu_calibration::PointXYZIR8Y>);
        pcl::fromROSMsg(*s_lidar, *cloud);
        //pcl::PointCloud<lidar_imu_calibration::PointXYZIR8Y>::Ptr cloud_downsampled(new pcl::PointCloud<lidar_imu_calibration::PointXYZIR8Y>);
        /// TODO :  Try Downsampling here
        //            downSampleCloud(cloud, cloud_downsampled, 1);
        /// Send it to linkalibr system
        
        double time_lidar = stamp2Sec(s_lidar->header.stamp);
        sys_->feed_measurement_lidar(time_lidar, cloud);
        VPointCloud cloud_undistorted = sys_->get_undistorted_cloud();
        sensor_msgs::msg::PointCloud2 cloud_undistorted_ros;
        pcl::toROSMsg(cloud_undistorted, cloud_undistorted_ros);
        cloud_undistorted_ros.header.frame_id = s_lidar->header.frame_id;
        cloud_undistorted_ros.header.stamp = s_lidar->header.stamp;
        undistorted_cloud_pub_->publish(cloud_undistorted_ros);

        State * state_k = sys_->get_state();
        Eigen::Vector3d G_t_Ik = state_k->_imu->pos();
        Eigen::Vector4d Ik_quat_imu_G = state_k->_imu->quat();
        Eigen::Matrix3d Ik_R_G = lidar_imu_calibration::quat_2_Rot(Ik_quat_imu_G);
        Eigen::Matrix3d G_R_Ik = Ik_R_G.transpose();
        Eigen::Matrix4d G_T_Ik = Eigen::Matrix4d::Identity();
        G_T_Ik.block(0, 0, 3, 3) = G_R_Ik;
        G_T_Ik.block(0, 3, 3, 1) = G_t_Ik;
        Eigen::Quaterniond quat_imu_k_eig(G_R_Ik);
        transform1.setOrigin(tf2::Vector3(G_t_Ik.x(), G_t_Ik.y(), G_t_Ik.z()));
        transform1.setRotation(tf2::Quaternion(quat_imu_k_eig.x(), quat_imu_k_eig.y(), quat_imu_k_eig.z(), quat_imu_k_eig.w()));
        // br1.sendTransform(tf2::Stamped<tf2::Transform>(transform1, tf2_ros::fromMsg(s_lidar->header.stamp), "map")); // TODO

        double t_ItoL = state_k->_calib_dt_LIDARtoIMU->value()(0);
        double timestamp_inI = state_k->_timestamp + t_ItoL;

        // Create pose of IMU (note we use the bag time)
        geometry_msgs::msg::PoseWithCovarianceStamped poseIinG;
        poseIinG.header.stamp = rclcpp::Time(timestamp_inI);
        poseIinG.header.frame_id = "map";
        poseIinG.pose.pose.orientation.x = quat_imu_k_eig.x();
        poseIinG.pose.pose.orientation.y = quat_imu_k_eig.y();
        poseIinG.pose.pose.orientation.z = quat_imu_k_eig.z();
        poseIinG.pose.pose.orientation.w = quat_imu_k_eig.w();
        poseIinG.pose.pose.position.x = G_t_Ik.x();
        poseIinG.pose.pose.position.y = G_t_Ik.y();
        poseIinG.pose.pose.position.z = G_t_Ik.z();
        // Finally set the covariance in the message (in the order position then orientation as per ros convention)
        std::vector<Type *> statevars;
        statevars.push_back(state_k->_imu->pose()->p());
        statevars.push_back(state_k->_imu->pose()->q());
        Eigen::Matrix<double, 6, 6> covariance_posori = StateHelper::get_marginal_covariance(sys_->get_state(), statevars);
        for (int r = 0; r < 6; r++) {
          for (int c = 0; c < 6; c++) {
            poseIinG.pose.covariance[6 * r + c] = covariance_posori(r, c);
          }
        }
        imu_pose_pub_->publish(poseIinG);

        RCLCPP_INFO_STREAM(get_logger(), "No of lodom: " << sys_->get_track_lidar()->get_odom_data().size());
        if (sys_->get_track_lidar()->get_odom_data().size() > 0) {
          Eigen::Matrix3d I_R_L = lidar_imu_calibration::quat_2_Rot(sys_->get_state()->_calib_LIDARtoIMU->quat());
          Eigen::Vector3d I_t_L = sys_->get_state()->_calib_LIDARtoIMU->pos();
          Eigen::Matrix4d I_T_L = Eigen::Matrix4d::Identity();
          I_T_L.block(0, 0, 3, 3) = I_R_L;
          I_T_L.block(0, 3, 3, 1) = I_t_L;
          if (first_lodom) {
            G_T_I1 = sys_->G_T_I1;
            first_lodom = false;
          }

          Eigen::Matrix4d I1_T_Ik = G_T_I1.inverse() * G_T_Ik;
          //Eigen::Vector3d I1_t_Ik = I1_T_Ik.block(0, 3, 3, 1);
          Eigen::Matrix3d I1_R_Ik = I1_T_Ik.block(0, 0, 3, 3);
          Eigen::Quaterniond I1_quat_Ik(I1_R_Ik);

          /// This the lidar pose in the L1 frame (not in G frame, where G is the world frame for system)
          Eigen::Matrix4d L1_T_Lk = sys_->get_track_lidar()->get_current_odometry().pose;
          Eigen::Vector3d L1_t_Lk = L1_T_Lk.block(0, 3, 3, 1);
          Eigen::Matrix3d L1_R_Lk = L1_T_Lk.block(0, 0, 3, 3);
          Eigen::Quaterniond L1_quat_Lk(L1_R_Lk);

          geometry_msgs::msg::PoseStamped pose_lidar;
          pose_lidar.header.stamp = s_lidar->header.stamp;
          pose_lidar.header.frame_id = s_lidar->header.frame_id; // TODO
          pose_lidar.pose.position.x = L1_t_Lk.x();
          pose_lidar.pose.position.y = L1_t_Lk.y();
          pose_lidar.pose.position.z = L1_t_Lk.z();
          pose_lidar.pose.orientation.x = L1_quat_Lk.x();
          pose_lidar.pose.orientation.y = L1_quat_Lk.y();
          pose_lidar.pose.orientation.z = L1_quat_Lk.z();
          pose_lidar.pose.orientation.w = L1_quat_Lk.w();
          lidar_pose_pub_->publish(pose_lidar);

          /// The following is the lidar pose in G frame
          Eigen::Matrix4d G_T_Lk = G_T_Ik * I_T_L;
          Eigen::Matrix3d G_R_Lk = G_T_Lk.block(0, 0, 3, 3);
          Eigen::Vector3d G_t_Lk = G_T_Lk.block(0, 3, 3, 1);
          Eigen::Quaterniond G_quat_Lk(G_R_Lk);

          if (first_lidar_frame) {
            first_lidar_frame = false;
            G_T_L1 = G_T_Lk;
            G_t_L1 = G_T_L1.block(0, 3, 3, 1);
            Eigen::Matrix3d G_R_L1 = G_T_L1.block(0, 0, 3, 3);
            G_quat_L1 = Eigen::Quaterniond(G_R_L1);
          }

          transform2.setOrigin(tf2::Vector3(G_t_Lk.x(), G_t_Lk.y(), G_t_Lk.z()));
          transform2.setRotation(tf2::Quaternion(G_quat_Lk.x(), G_quat_Lk.y(), G_quat_Lk.z(), G_quat_Lk.w()));
          // br2.sendTransform(tf2::Stamped<tf2::Transform>(transform2, tf2_ros::fromMsg(s_lidar->header.stamp), "map")); // TODO

          transform3.setOrigin(tf2::Vector3(G_t_L1.x(), G_t_L1.y(), G_t_L1.z()));
          transform3.setRotation(tf2::Quaternion(G_quat_L1.x(), G_quat_L1.y(), G_quat_L1.z(), G_quat_L1.w()));
          // br3.sendTransform(tf2::Stamped<tf2::Transform>(transform3, tf2_ros::fromMsg(s_lidar->header.stamp), "map")); // TODO
        }
        if (sys_->get_track_lidar()->isKeyFrame()) {
          pcl::PointCloud<pcl::PointXYZI>::Ptr map_cloud(new pcl::PointCloud<pcl::PointXYZI>);
          map_cloud = sys_->get_track_lidar()->getTargetMap();
          sensor_msgs::msg::PointCloud2 map_cloud_ros;
          pcl::toROSMsg(*map_cloud, map_cloud_ros);
          map_cloud_ros.header.frame_id = "map";
          map_cloud_ros.header.stamp = s_lidar->header.stamp;
          map_pub_->publish(map_cloud_ros);
        }
      }
      else {
        sensor_msgs::msg::Imu::SharedPtr s_imu = std::make_shared<sensor_msgs::msg::Imu>();
        imu_serialization_.deserialize_message(&serialized_msg, s_imu.get());
        imu_pub_->publish(*s_imu);

        double time_imu = stamp2Sec(s_imu->header.stamp);
        Eigen::Vector3d wm, am;
        wm << s_imu->angular_velocity.x, s_imu->angular_velocity.y, s_imu->angular_velocity.z;
        am << s_imu->linear_acceleration.x, s_imu->linear_acceleration.y, s_imu->linear_acceleration.z;

        State * state = sys_->get_state();
        Eigen::Matrix<double, 13, 1> state_plus = Eigen::Matrix<double, 13, 1>::Zero();
        sys_->get_propagator()->fast_state_propagate(state, time_imu, state_plus);

        /// Send it to our linkalibr system
        sys_->feed_measurement_imu(time_imu, wm, am);
        no_of_imu++;

        // Our odometry message
        nav_msgs::msg::Odometry odomIinM;
        odomIinM.header.stamp = s_imu->header.stamp;
        odomIinM.header.frame_id = "map";
        odomIinM.child_frame_id = s_imu->header.frame_id;

        // The POSE component (orientation and position)
        odomIinM.pose.pose.orientation.x = state_plus(0);
        odomIinM.pose.pose.orientation.y = state_plus(1);
        odomIinM.pose.pose.orientation.z = state_plus(2);
        odomIinM.pose.pose.orientation.w = state_plus(3);
        odomIinM.pose.pose.position.x = state_plus(4);
        odomIinM.pose.pose.position.y = state_plus(5);
        odomIinM.pose.pose.position.z = state_plus(6);

        // Finally set the covariance in the message (in the order position then orientation as per ros convention)
        std::vector<Type *> statevars;
        statevars.push_back(state->_imu->pose()->p());
        statevars.push_back(state->_imu->pose()->q());
        Eigen::Matrix<double, 6, 6> covariance_posori = StateHelper::get_marginal_covariance(sys_->get_state(), statevars);
        for (int r = 0; r < 6; r++) {
          for (int c = 0; c < 6; c++) {
            odomIinM.pose.covariance[6 * r + c] = covariance_posori(r, c);
          }
        }

        // The TWIST component (angular and linear velocities)
        odomIinM.twist.twist.linear.x = state_plus(7);
        odomIinM.twist.twist.linear.y = state_plus(8);
        odomIinM.twist.twist.linear.z = state_plus(9);
        odomIinM.twist.twist.angular.x = state_plus(10);  // we do not estimate this...
        odomIinM.twist.twist.angular.y = state_plus(11);  // we do not estimate this...
        odomIinM.twist.twist.angular.z = state_plus(12);  // we do not estimate this...

        // Velocity covariance (linear then angular)
        statevars.clear();
        statevars.push_back(state->_imu->v());
        Eigen::Matrix<double, 6, 6> covariance_linang = INFINITY * Eigen::Matrix<double, 6, 6>::Identity();
        covariance_linang.block(0, 0, 3, 3) = StateHelper::get_marginal_covariance(sys_->get_state(), statevars);
        for (int r = 0; r < 6; r++) {
          for (int c = 0; c < 6; c++) {
            odomIinM.twist.covariance[6 * r + c] = (std::isnan(covariance_linang(r, c))) ? 0 : covariance_linang(r, c);
          }
        }

        // Finally, publish the resulting odometry message
        imu_odom_pub_->publish(odomIinM);
      }
    }

    rclcpp::Time end_time = now();
    RCLCPP_INFO_STREAM(get_logger(), "Reached end of bag");
    RCLCPP_INFO_STREAM(get_logger(), "Kalman Filtering took : " << stamp2Sec(end_time) - stamp2Sec(start_time) << " [s]");
    /// Write the final I_T_L to a text file
    State * state = sys_->get_state();
    Pose * calibration = state->_calib_LIDARtoIMU;
    Eigen::Matrix3d I_R_L = calibration->Rot();
    Eigen::Vector3d I_t_L = calibration->pos();
    Eigen::Matrix4d I_T_L = Eigen::Matrix4d::Identity();
    I_T_L.block(0, 0, 3, 3) = I_R_L;
    I_T_L.block(0, 3, 3, 1) = I_t_L;
    std::cout << "Writing KF calibration result to: " << getCalibManagerOptions().lidar_inertial_calibration_result_filename << std::endl;
    std::ofstream result_calibration;
    result_calibration.open(getCalibManagerOptions().lidar_inertial_calibration_result_filename.c_str());
    result_calibration << I_T_L;
    result_calibration.close();
    std::cout << "I_T_L: " << std::endl;
    std::cout << I_T_L << std::endl;
    Eigen::Vector3d eulerXYZ = I_R_L.eulerAngles(0, 1, 2) * 180 / M_PI;
    RCLCPP_INFO_STREAM(get_logger(), "Translation [in m]: " << I_t_L.transpose());
    RCLCPP_INFO_STREAM(get_logger(), "Euler Angles [in deg]: " << eulerXYZ.transpose());
  }

private:

  template <typename T>
  double stamp2Sec(const T & stamp)
  {
    return rclcpp::Time(stamp).seconds();
  }

  template <typename T>
  double stamp2NanoSec(const T & stamp)
  {
    return RCUTILS_S_TO_NS(rclcpp::Time(stamp).seconds());
  }

  calibManager * sys_{nullptr};

  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr cloud_pub_;

  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr undistorted_cloud_pub_;

  rclcpp::Publisher<sensor_msgs::msg::Imu>::SharedPtr imu_pub_;

  rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr lidar_pose_pub_;

  rclcpp::Publisher<geometry_msgs::msg::PoseWithCovarianceStamped>::SharedPtr imu_pose_pub_;

  rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr imu_odom_pub_;

  rclcpp::Publisher<sensor_msgs::msg::PointCloud2>::SharedPtr map_pub_;

  rosbag2_cpp::Reader reader_;

  rclcpp::Serialization<sensor_msgs::msg::Imu> imu_serialization_;

  rclcpp::Serialization<sensor_msgs::msg::PointCloud2> cloud_serialization_;

  /// Location of the ROS bag we want to read in
  std::string path_to_bag_;

  std::string topic_imu_;

  std::string topic_lidar_;

  /// Get our start location and how much of the bag we want to play
  /// Make the bag duration < 0 to just process to the end of the bag
  double bag_start_, bag_durr_;
};

int main(int argc, char ** argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<LidarImuCalibrationNode>());
  rclcpp::shutdown();
  return 0;
}
